# Numpyの基礎

## 配列
* `numpy.array`
* 例：`numpy.array([1, 2, 3, 4, 5])`
* データ型
  * Numpyで扱うデータが保持している型情報
    * 計算の高速化のため
    * 精度
  * オブジェクト`.dtype`で取得可能
  * データ型の種類：
    * int8～64
    * uint8～64
    * float16～128
    * bool
* 次元数
  * オブジェクト`.ndim`で取得可能
* 要素数
  * オブジェクト`.size`で取得可能
* 全要素に対する四則演算
  * 例： `numpy.array([1,2,3]) * 2 # array([2,4,6])`
  * 一応：演算の順序に注意。`2 * numpy.array([1,2,3])`はエラーとなる
* slice
  * `配列[start:stop:step]`という形式でslice可能
  * `step`は負の数も指定可能（`start`から逆方向に取得可能）
  * 構文はNumpyというよりPythonの機能（標準機能以外でもこの構文が使えるので、何かしらのインターフェースがある？自作も可能？）
    * `numpy.array`だけでなく、通常のlist型にも同じ構文が使える
* ソート
  * 例：`numpy.array([1,2,3]).sort()`
  * 副作用あり（配列の中身が変わる）
* 最大、最小、合計、積み上げ
  * 最小：`配列.min()`
  * 最大：`配列.max()`
  * 合計：`配列.sum()`
  * 積み上げ:`配列.cumsum()`

## 乱数
* 乱数：`numpy.random`
* 用途
  * 収集したデータをランダムに分離する
  * ランダムな値を加えてばらつきを出す
  * etc...
* シード：`random.seed(seed)`
  * 乱数の元になるもの
  * シードが同じなら、乱数生成の結果も毎回同じになる
  * データ分析では、データ検証結果が毎回異なってしまわないように、シードを設定することが多いらしい
* 乱数生成
  * 一様分布、正規分布、二項分布、ベータ分布、ガンマ分布など、様々な種類をサポート
* ランダム抽出
  * 復元抽出: 重複を許して抽出
  * 非復元抽出: 重複せずに抽出

## コラム：Numpyは高速
* 例えば、標準関数`sum`と、`numpy.sum`とで比較すると、後者の方が早い
* `%timeit`で時間計測可能
  * `%timeit sum(array_data)`

## 行列
* `numpy.array`を`.reshape`で行列に変換
* `numpy.dot`で行列の積計算
* `+-*/`は行列内要素の四則演算になる
  * 例えば`*n`は行列内要素を一律`n`倍したものになる
  * 上記`n`は、数値以外にも行列を使うことができる（対応する`index`同士が計算される）